# Hierarchical Specification Framework

**Version 3.5.2** | [Changelog](CHANGELOG.md)

A structured approach to software specification that enforces **dependency inversion**: foundational philosophy guides implementation, never vice versa.

**ü§ñ AI-First Design:** While this framework can be used manually, it is specifically designed for AI assistants and agents to help you create, maintain, and validate comprehensive product specifications.

## Overview

This repository contains a complete hierarchical specification framework designed to maintain architectural coherence across software projects. The framework enforces strict separation of concerns across five levels, from philosophical foundations to implementation details.

**Core Principle:** Each concern lives at exactly one level (single source of truth). Changes flow downward through abstraction layers while foundational documents remain stable.

**AI-Assisted Workflow:** This framework shines when used with AI assistants like Claude Code, which can guide you through the specification process, validate hierarchy rules, and ensure consistency across levels.

## The Five Levels

| Level                           | Purpose                              | Key Question                                          | References                   |
| ------------------------------- | ------------------------------------ | ----------------------------------------------------- | ---------------------------- |
| **1: Foundational Philosophy**  | WHY & WHAT EXPERIENCE                | "What problem must we solve? What should users feel?" | External only                |
| **2: Stable Truths**            | Design strategies & commitments      | "What approach will we take?"                         | L1 + External                |
| **3: Interaction Architecture** | HOW users and product interact       | "What's the behavioral pattern?"                      | L1-2 + External              |
| **4: Systems**                  | Implementation architecture          | "How do we build this?"                               | L1-3 + Sibling L4 + External |
| **5: Implementation**           | Validation (YAML + Cypress) & tuning | "Does it work? What values?"                          | All levels + External        |

### Reference Rules

**CRITICAL**: Each level has strict reference constraints to maintain architectural integrity:

1. **Level 1** can only reference external resources
2. **Level 2** can reference Level 1 + external resources
3. **Level 3** can reference Levels 1-2 + external resources
4. **Level 4** can reference Levels 1-3 + sibling Level 4 docs + external resources
5. **Level 5** can reference all levels + external resources

**Never reference lower levels from higher levels** (e.g., don't reference Level 4 Systems from Level 3 Interaction Architecture).

## Key Features

- **Strict Reference Hierarchy**: Higher levels cannot reference lower levels, preventing circular dependencies
- **Single Source of Truth**: Each concern lives at exactly one level
- **Dependency Inversion**: Philosophy drives implementation, not the reverse
- **Scalable Architecture**: Systems remain loosely coupled while maintaining clear interaction patterns
- **Future-Proof Design**: Stable upper levels protect against constant churn in implementation details
- **Automated Testing**: User stories in YAML format automatically generate Cypress end-to-end tests

## Why This Framework?

### Philosophy: Validation in an AI-Driven World

In an AI-driven world, **validation and proof are the real value generators**. Code, specifications, and even ideas can be trivially generated by AI systems. The true value‚Äîand the real challenge‚Äîlies in **review, validation, and proof** of what was built.

This matters because:

**Non-deterministic execution requires proof.** AI systems can *claim* they implemented something, but given the non-deterministic nature of LLMs, we cannot trust claims alone. The proof is the most important part.

**Professional integrity demands it.** At professional, enterprise, and state-of-the-art levels, integrity matters as much as the product itself. Without proof, we cannot ship something that was built by AI. Full stop.

**This framework is designed to provide that proof** through:

1. **Top-down goal fulfillment** - Start with first principles and Design Pillars that give us "Why" (otherwise there's no point)
2. **Strategic clarity** - Determine "What" we need to build to fulfill that philosophy
3. **Behavioral patterns** - Define "How" users and product interact at a high level
4. **System architecture** - Figure out the Systems that comprise the product
5. **User validation** - Implement those systems from the user's perspective (stories that become executable tests)

**Implementation details only matter insofar as they fulfill our needs.** We stay pragmatic‚Äîperformance is a need, over-engineering is not. The framework keeps us honest: every detail must trace back to a user need, which must trace back to a Design Pillar, which must serve the mission.

In this way, the framework transforms AI-generated code from "unverifiable claims" into "proven implementations."

### Philosophy & Motivation

Traditional specification approaches often suffer from **circular dependencies** and **implementation-driven design**:

- **Bottom-up specifications** start with features, leading to incoherent user experiences
- **Implementation-first thinking** couples architecture to implementation details
- **Spec drift** occurs when documentation doesn't match actual product philosophy
- **Feature creep** happens without clear decision filters

**This framework solves these problems through dependency inversion:**

```
Philosophy (Level 1)
    ‚Üì guides
Strategy (Level 2)
    ‚Üì guides
Interaction Patterns (Level 3)
    ‚Üì guides
System Architecture (Level 4)
    ‚Üì guides
Implementation & Tests (Level 5)
```

**Key benefits:**

1. **Stable foundations** - Philosophy doesn't change when you adjust implementation
2. **Clear decision-making** - Design Pillars filter feature requests
3. **Architectural integrity** - High-level policy guides low-level details
4. **Living documentation** - YAML user stories auto-generate tests
5. **Team alignment** - Shared understanding from "why" to "how much"

**Trade-offs:**

- **More upfront structure** vs. "just start coding"
- **Disciplined hierarchy** vs. flexible documentation
- **Best for:** Complex products, long-lived systems, team collaboration
- **Not ideal for:** Throwaway prototypes, single-developer experiments

### When to Use This Framework

**Use this framework when:**

- Building complex products with multiple interconnected systems
- Working with teams that need aligned understanding
- Creating long-lived systems that will evolve over years
- You need to maintain coherent user experience across features
- Specifications need to guide both human and AI implementation

**Example domains:**

- SaaS platforms (project management, CRM, analytics)
- Games (RPGs, strategy games, simulation)
- Education tools (learning platforms, course management)
- Healthcare applications (patient portals, clinical systems)
- Financial services (trading platforms, banking apps)

**Don't use this framework when:**

- Building a quick MVP to test market fit (use lighter docs)
- Throwaway prototype or proof-of-concept
- Project has no clear philosophical foundation yet
- Team prefers pure agile/emergent design

### How This Compares to Other Approaches

#### vs. Traditional PRDs (Product Requirements Documents)

**Traditional PRD:**

- Lists features and requirements
- Often implementation-first
- Philosophy emerges from features (if at all)
- Updates lag behind implementation

**This Framework:**

- Starts with philosophy and experience
- Features must support Design Pillars
- Implementation guided by stable truths
- Specifications drive implementation

#### vs. User Stories Only

**User Stories Only:**

- Good for capturing user needs
- Lacks architectural coherence
- No philosophical foundation
- Features can contradict each other

**This Framework:**

- User stories validate system implementations (Level 5)
- Backed by system architecture (Level 4)
- Guided by interaction patterns (Level 3)
- Aligned with philosophical foundations (Levels 1-2)

#### vs. Code-as-Specification

**Code-as-Spec:**

- Implementation IS the specification
- No separation of concerns
- Philosophy implicit in code
- Hard to validate alignment

**This Framework:**

- Specification guides code
- Clear separation: why/what/how/how-much
- Philosophy explicit and stable
- Easy to validate implementation against spec

## Getting Started

Choose your path based on your project stage:

### Path 1: New Project (Greenfield)

**Starting from scratch with a new product concept**

**Step 1: Copy the framework definition to your project**

```bash
# Download the framework file
curl -O https://raw.githubusercontent.com/caudexia/spec-framework/main/00.SPEC_FRAMEWORK.md

# Or manually download and copy 00.SPEC_FRAMEWORK.md to your project root
```

**Step 2: Generate your specification with AI**

Use the detailed prompt: **[prompts/initialize-spec.md](prompts/initialize-spec.md)**

The AI will:
- Read `00.SPEC_FRAMEWORK.md` to understand the framework structure
- Ask you questions level-by-level (WHY ‚Üí WHAT ‚Üí HOW ‚Üí HOW MUCH)
- Generate your complete specification files (01-05)

**Time estimate:** 2-4 hours for initial draft

**Step 3: Your project structure becomes:**

```
your-project/
‚îú‚îÄ‚îÄ 00.SPEC_FRAMEWORK.md           # Framework definition (reference, read-only)
‚îú‚îÄ‚îÄ 01.FOUNDATIONAL_PHILOSOPHY.md  # Generated: Your WHY & WHAT EXPERIENCE
‚îú‚îÄ‚îÄ 02.STABLE_TRUTHS.md            # Generated: Your design strategies
‚îú‚îÄ‚îÄ 03.INTERACTION_ARCHITECTURE.md # Generated: Your interaction patterns
‚îú‚îÄ‚îÄ 04.SYSTEMS/                    # Generated: Your system specs
‚îÇ   ‚îú‚îÄ‚îÄ SYSTEMS_OVERVIEW.md
‚îÇ   ‚îî‚îÄ‚îÄ [YOUR_SYSTEMS].md
‚îî‚îÄ‚îÄ 05.IMPLEMENTATION/             # Generated: User stories (YAML‚ÜíCypress) & parameters
    ‚îú‚îÄ‚îÄ USER_STORIES/              # YAML files with auto-generated Cypress tests
    ‚îî‚îÄ‚îÄ FINE_TUNING/               # Numeric parameter YAML files
```

**Step 4: (Optional) Set up automated testing**

See **[docs/CYPRESS_SETUP.md](docs/CYPRESS_SETUP.md)** for complete Cypress integration guide.

Your YAML user stories will automatically generate end-to-end tests.

---

### Path 2: Existing Project (Brownfield)

**Applying the framework to an existing codebase or product**

**Step 1: Copy the framework definition**

```bash
cd your-existing-project/
curl -O https://raw.githubusercontent.com/caudexia/spec-framework/main/00.SPEC_FRAMEWORK.md
```

**Step 2: Choose your approach**

**Specification-First (Recommended):**
- Define ideal philosophy and architecture
- Document what SHOULD exist
- Create gap analysis vs. current state
- Refactor incrementally toward spec

**Reverse-Engineering (Pragmatic):**
- Document current architecture as-is
- Infer implicit design decisions
- Extract retrospective philosophy
- Validate spec matches reality

**Step 3: Generate specification with AI**

Use the detailed prompt: **[prompts/adopt-framework-existing.md](prompts/adopt-framework-existing.md)**

The AI will help you:
- Map existing code to framework levels
- Define Design Pillars that match your decisions
- Create gap analysis (if Specification-First)
- Document current state accurately (if Reverse-Engineering)

**Time estimate:** 4-8 hours depending on codebase size

**Step 4: Establish as single source of truth**

- Use Design Pillars to filter roadmap
- Reference spec in PRs and planning
- Gradual migration over 3-6 months (if Specification-First)
- Ongoing maintenance (if Reverse-Engineering)

**See [docs/QUICK_START.md](docs/QUICK_START.md) for detailed workflows.**

---

### Path 3: Learning the Framework

**Understanding the framework before committing**

1. **Read [00.SPEC_FRAMEWORK.md](00.SPEC_FRAMEWORK.md)** - Complete framework structure and rules
2. **Read [CLAUDE.md](CLAUDE.md)** - AI assistant quick reference
3. **Review [templates/USER_STORIES/](templates/USER_STORIES/)** - See YAML examples
4. **Check [CHANGELOG.md](CHANGELOG.md)** - Version history and evolution
5. **Try [docs/QUICK_START.md](docs/QUICK_START.md)** - Fast-track guides for both scenarios

**Time investment:** 1-2 hours to understand, 2-8 hours to create your first spec

## Working with AI Assistants

This framework is specifically designed for AI-assisted specification development. Use the prompts below with AI assistants (Claude, GPT-4, etc.) to create and maintain your specifications.

**Quick workflow:**

1. Copy `00.SPEC_FRAMEWORK.md` to your project
2. Use a prompt from the sections below (or from [prompts/](prompts/) for detailed versions)
3. AI reads framework and generates your spec files (01-05)

**üìö Full prompt library:** See [prompts/](prompts/) directory for detailed, comprehensive prompts for every use case.

---

<details>
<summary>üöÄ <strong>Initialize a New Specification</strong></summary>

<br/>

**Quick prompt:**

```
I have copied 00.SPEC_FRAMEWORK.md to my project.

My product idea: [Brief description]

Help me create my specification by asking questions about:
1. Level 1: Mission, 3-5 Design Pillars, inviolable principles
2. Level 2: Design strategies and commitments
3. Level 3: Interaction patterns
4. Level 4: System architecture
5. Level 5: User stories (YAML) and parameters

Follow framework rules: hierarchy, placeholders in L1-4, no upward references.
```

**üìñ Detailed prompt:** [prompts/initialize-spec.md](prompts/initialize-spec.md)

</details>

<details>
<summary>üîÑ <strong>Migrate Specification to Newer Version</strong></summary>

<br/>

**Quick prompt:**

```
I have a spec using framework v[OLD_VERSION]. I've updated to v3.5.2.

Read CHANGELOG.md and help me migrate:
1. Identify breaking changes
2. Rename files if needed
3. Convert user stories to YAML (if from v2.x)
4. Update all cross-references
5. Validate against new framework rules
```

**üìñ Detailed prompt:** [prompts/migrate-spec.md](prompts/migrate-spec.md)

</details>

<details>
<summary>‚úÖ <strong>Validate an Existing Specification</strong></summary>

<br/>

**Quick prompt:**

```
Validate my specification against framework v3.5.2:

Check:
- Reference hierarchy (no upward references)
- No numeric values in L1-4 (placeholders only)
- Design Pillars are emotional, not features
- User stories have test DSL
- All required sections present

Report violations with file:line and suggested fixes.
```

**üìñ Detailed prompt:** [prompts/validate-spec.md](prompts/validate-spec.md)

</details>

<details>
<summary>üîç <strong>Add Feature to Existing Specification</strong></summary>

<br/>

**Quick prompt:**

```
I want to add a new feature: [Description]

Help me:
1. Check which Design Pillar(s) it supports
2. Determine which levels need updates
3. Draft changes for each affected level
4. Ensure changes flow downward only
5. Create user stories and tests (L5)
```

**üìñ Detailed prompt:** [prompts/add-feature.md](prompts/add-feature.md)

</details>

<details>
<summary>üìä <strong>Generate Documentation from Spec</strong></summary>

<br/>

**Quick prompt:**

```
Generate from my specification:
- PRD (Product Requirements Document)
- TDD (Technical Design Document)
- User Story Backlog
- Design Pillar Validation Matrix

Maintain traceability to spec levels.
```

**üìñ Detailed prompt:** [prompts/generate-docs.md](prompts/generate-docs.md)

</details>

<details>
<summary>üéØ <strong>Review Feature Against Specification</strong></summary>

<br/>

**Quick prompt:**

```
Review this feature/implementation: [Description or code]

Check alignment with:
1. L1: Design Pillars and principles
2. L2: Design strategies
3. L3: Interaction patterns
4. L4: System boundaries
5. L5: Parameters

Verdict: ‚úÖ Approved / ‚ö†Ô∏è Needs Changes / ‚ùå Violates Spec
```

**üìñ Detailed prompt:** [prompts/review-feature.md](prompts/review-feature.md)

</details>

---

### Tips for Best Results

**When working with AI assistants:**

1. **Be specific** - Provide context about your domain and constraints
2. **Answer thoroughly** - AI uses your answers to generate better specs
3. **Iterate** - Refine AI-generated content based on your expertise
4. **Validate frequently** - Use the validation prompt regularly
5. **Question suggestions** - If something feels wrong, speak up

**Common commands:**

- `"Check if this violates any hierarchy rules"`
- `"Generate 3 user stories for [SYSTEM] in YAML format"`
- `"Does this feature support at least one Design Pillar?"`
- `"Rewrite this without referencing Level 4 systems"`

**For more tips:** See [prompts/tips-and-best-practices.md](prompts/tips-and-best-practices.md)

---

### Framework-Aware AI Assistants

This framework includes guidance files that AI assistants automatically read:

- **CLAUDE.md** - Brief quick reference for Claude Code
- **00.SPEC_FRAMEWORK.md** - Complete framework specification
- **prompts/** - Detailed prompts for all use cases

When working in a directory containing these files, AI assistants will:

- Understand the five-level hierarchy
- Enforce reference rules
- Guide you through level-by-level specification
- Validate against anti-patterns
- Help create YAML user stories with test DSL

---

## Version Information

**Current Version:** 3.5.2

This framework follows [Semantic Versioning](https://semver.org/):

- **Major versions** (2.0.0) include breaking changes requiring migration
- **Minor versions** (2.1.0) add features while maintaining compatibility
- **Patch versions** (2.0.1) fix bugs and clarify documentation

See [CHANGELOG.md](CHANGELOG.md) for:

- Complete version history
- Migration guides for major version upgrades
- Detailed list of changes in each release

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contributing

[Add contribution guidelines here]
