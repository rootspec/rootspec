<p align="center">
  <img src="assets/rootspec-banner.png" alt="RootSpec" width="600">
</p>

<h1 align="center">RootSpec</h1>

<p align="center">
  <strong>Hierarchical Specification Framework</strong><br>
  Philosophy guides implementation, never vice versa.
</p>

<p align="center">
  <a href="CHANGELOG.md">Changelog</a> ‚Ä¢
  <a href="docs/QUICK_START.md">Quick Start</a> ‚Ä¢
  <a href="prompts/">Prompts</a>
</p>

<p align="center">
  <a href="https://www.npmjs.com/package/rootspec"><img src="https://img.shields.io/npm/v/rootspec.svg?style=flat-square" alt="npm version"></a>
  <a href="https://www.npmjs.com/package/rootspec"><img src="https://img.shields.io/npm/dm/rootspec.svg?style=flat-square" alt="npm downloads"></a>
  <a href="LICENSE"><img src="https://img.shields.io/badge/License-MIT-yellow.svg?style=flat-square" alt="License: MIT"></a>
  <a href="https://github.com/rootspec/rootspec"><img src="https://img.shields.io/github/stars/rootspec/rootspec?style=flat-square" alt="GitHub stars"></a>
</p>

---

**Version 4.1.0**

A structured approach to software specification that enforces **dependency inversion**: foundational philosophy guides implementation, never vice versa.

**AI-First Design:** Built for AI assistants to help you create, maintain, and validate comprehensive product specifications.

## Overview

This repository contains a complete hierarchical specification framework designed to maintain architectural coherence across software projects. The framework enforces strict separation of concerns across five levels, from philosophical foundations to implementation details.

**Core Principle:** Each concern lives at exactly one level (single source of truth). Changes flow downward through abstraction layers while foundational documents remain stable.

**AI-Assisted Workflow:** This framework shines when used with AI assistants like Claude Code, which can guide you through the specification process, validate hierarchy rules, and ensure consistency across levels.

## The Five Levels

| Level                           | Purpose                              | Key Question                                          | References                   |
| ------------------------------- | ------------------------------------ | ----------------------------------------------------- | ---------------------------- |
| **1: Foundational Philosophy**  | WHY & WHAT EXPERIENCE                | "What problem must we solve? What should users feel?" | External only                |
| **2: Stable Truths**            | Design strategies & commitments      | "What approach will we take?"                         | L1 + External                |
| **3: Interaction Architecture** | HOW users and product interact       | "What's the behavioral pattern?"                      | L1-2 + External              |
| **4: Systems**                  | Implementation architecture          | "How do we build this?"                               | L1-3 + Sibling L4 + External |
| **5: Implementation**           | Validation (YAML + Cypress) & tuning | "Does it work? What values?"                          | All levels + External        |

### Reference Rules

**CRITICAL**: Each level has strict reference constraints to maintain architectural integrity:

1. **Level 1** can only reference external resources
2. **Level 2** can reference Level 1 + external resources
3. **Level 3** can reference Levels 1-2 + external resources
4. **Level 4** can reference Levels 1-3 + sibling Level 4 docs + external resources
5. **Level 5** can reference all levels + external resources

**Never reference lower levels from higher levels** (e.g., don't reference Level 4 Systems from Level 3 Interaction Architecture).

## Key Features

- **Strict Reference Hierarchy**: Higher levels cannot reference lower levels, preventing circular dependencies
- **Single Source of Truth**: Each concern lives at exactly one level
- **Dependency Inversion**: Philosophy drives implementation, not the reverse
- **Scalable Architecture**: Systems remain loosely coupled while maintaining clear interaction patterns
- **Future-Proof Design**: Stable upper levels protect against constant churn in implementation details
- **Automated Testing**: User stories in YAML format automatically generate Cypress end-to-end tests

## Why This Framework?

### Philosophy: Validation in an AI-Driven World

In an AI-driven world, **validation and proof are the real value generators**. Code, specifications, and even ideas can be trivially generated by AI systems. The true value‚Äîand the real challenge‚Äîlies in **review, validation, and proof** of what was built.

This matters because:

**Non-deterministic execution requires proof.** AI systems can *claim* they implemented something, but given the non-deterministic nature of LLMs, we cannot trust claims alone. The proof is the most important part.

**Professional integrity demands it.** At professional, enterprise, and state-of-the-art levels, integrity matters as much as the product itself. Without proof, we cannot ship something that was built by AI. Full stop.

**This framework is designed to provide that proof** through:

1. **Top-down goal fulfillment** - Start with first principles and Design Pillars that give us "Why" (otherwise there's no point)
2. **Strategic clarity** - Determine "What" we need to build to fulfill that philosophy
3. **Behavioral patterns** - Define "How" users and product interact at a high level
4. **System architecture** - Figure out the Systems that comprise the product
5. **User validation** - Implement those systems from the user's perspective (stories that become executable tests)

**Implementation details only matter insofar as they fulfill our needs.** We stay pragmatic‚Äîperformance is a need, over-engineering is not. The framework keeps us honest: every detail must trace back to a user need, which must trace back to a Design Pillar, which must serve the mission.

In this way, the framework transforms AI-generated code from "unverifiable claims" into "proven implementations."

### Philosophy & Motivation

Traditional specification approaches often suffer from **circular dependencies** and **implementation-driven design**:

- **Bottom-up specifications** start with features, leading to incoherent user experiences
- **Implementation-first thinking** couples architecture to implementation details
- **Spec drift** occurs when documentation doesn't match actual product philosophy
- **Feature creep** happens without clear decision filters

**This framework solves these problems through dependency inversion:**

```
Philosophy (Level 1)
    ‚Üì guides
Strategy (Level 2)
    ‚Üì guides
Interaction Patterns (Level 3)
    ‚Üì guides
System Architecture (Level 4)
    ‚Üì guides
Implementation & Tests (Level 5)
```

**Key benefits:**

1. **Stable foundations** - Philosophy doesn't change when you adjust implementation
2. **Clear decision-making** - Design Pillars filter feature requests
3. **Architectural integrity** - High-level policy guides low-level details
4. **Living documentation** - YAML user stories auto-generate tests
5. **Team alignment** - Shared understanding from "why" to "how much"

**Trade-offs:**

- **More upfront structure** vs. "just start coding"
- **Disciplined hierarchy** vs. flexible documentation
- **Best for:** Complex products, long-lived systems, team collaboration
- **Not ideal for:** Throwaway prototypes, single-developer experiments

### When to Use This Framework

**Use this framework when:**

- Building complex products with multiple interconnected systems
- Working with teams that need aligned understanding
- Creating long-lived systems that will evolve over years
- You need to maintain coherent user experience across features
- Specifications need to guide both human and AI implementation

**Example domains:**

- SaaS platforms (project management, CRM, analytics)
- Games (RPGs, strategy games, simulation)
- Education tools (learning platforms, course management)
- Healthcare applications (patient portals, clinical systems)
- Financial services (trading platforms, banking apps)

**Don't use this framework when:**

- Building a quick MVP to test market fit (use lighter docs)
- Throwaway prototype or proof-of-concept
- Project has no clear philosophical foundation yet
- Team prefers pure agile/emergent design

### How This Compares to Other Approaches

#### vs. Traditional PRDs (Product Requirements Documents)

**Traditional PRD:**

- Lists features and requirements
- Often implementation-first
- Philosophy emerges from features (if at all)
- Updates lag behind implementation

**This Framework:**

- Starts with philosophy and experience
- Features must support Design Pillars
- Implementation guided by stable truths
- Specifications drive implementation

#### vs. User Stories Only

**User Stories Only:**

- Good for capturing user needs
- Lacks architectural coherence
- No philosophical foundation
- Features can contradict each other

**This Framework:**

- User stories validate system implementations (Level 5)
- Backed by system architecture (Level 4)
- Guided by interaction patterns (Level 3)
- Aligned with philosophical foundations (Levels 1-2)

#### vs. Code-as-Specification

**Code-as-Spec:**

- Implementation IS the specification
- No separation of concerns
- Philosophy implicit in code
- Hard to validate alignment

**This Framework:**

- Specification guides code
- Clear separation: why/what/how/how-much
- Philosophy explicit and stable
- Easy to validate implementation against spec

## Installation

RootSpec v4.0+ includes a CLI that automates framework setup and prompt generation.

### Using npm (Recommended)

```bash
# Install globally
npm install -g rootspec

# Or use directly with npx (no installation)
npx rootspec init
```

### Manual Installation (Alternative)

If you prefer not to use npm or need offline access, you can manually download the framework:

```bash
curl -O https://raw.githubusercontent.com/rootspec/rootspec/main/00.SPEC_FRAMEWORK.md
```

**Note:** The CLI provides additional commands for generating AI prompts with auto-detected project context, Cypress test setup, and specification validation. See `rootspec --help` for all commands.

## Getting Started

Choose your path based on your project stage:

### Path 1: New Project (Greenfield)

**Starting from scratch with a new product concept**

**Step 1: Initialize RootSpec in your project**

```bash
# Initialize with CLI (creates spec/ directory and copies framework)
npx rootspec init

# Or specify custom path
npx rootspec init --path ./docs/spec
```

This creates:
- `spec/00.SPEC_FRAMEWORK.md` - Framework definition (reference)
- `.rootspecrc.json` - Configuration file tracking your setup

**Step 2: Generate your specification with AI**

```bash
# Generate AI prompt for new project
rootspec prompts init
```

This command:
- **Scans your project structure** (detects framework, source directories, config files)
- **Generates a ready-to-use prompt** with your project context already filled in
- **Outputs** a prompt you can paste directly into your AI assistant (Claude, ChatGPT, etc.)

The AI will then:
- Read `00.SPEC_FRAMEWORK.md` to understand the framework structure
- Ask you questions level-by-level (WHY ‚Üí WHAT ‚Üí HOW ‚Üí HOW MUCH)
- Generate your complete specification files (01-05)

**Time estimate:** 2-4 hours for initial draft

<details>
<summary><strong>Alternative: Manual workflow (without CLI)</strong></summary>

If you prefer not to use the CLI:

1. Download the framework file:
   ```bash
   curl -O https://raw.githubusercontent.com/rootspec/rootspec/main/00.SPEC_FRAMEWORK.md
   ```

2. Read and copy the prompt from **[prompts/initialize-spec.md](prompts/initialize-spec.md)**, manually filling in your project details

3. Paste into your AI assistant

</details>

**Step 3: Your project structure becomes:**

```
your-project/
‚îú‚îÄ‚îÄ 00.SPEC_FRAMEWORK.md           # Framework definition (reference, read-only)
‚îú‚îÄ‚îÄ 01.FOUNDATIONAL_PHILOSOPHY.md  # Generated: Your WHY & WHAT EXPERIENCE
‚îú‚îÄ‚îÄ 02.STABLE_TRUTHS.md            # Generated: Your design strategies
‚îú‚îÄ‚îÄ 03.INTERACTION_ARCHITECTURE.md # Generated: Your interaction patterns
‚îú‚îÄ‚îÄ 04.SYSTEMS/                    # Generated: Your system specs
‚îÇ   ‚îú‚îÄ‚îÄ SYSTEMS_OVERVIEW.md
‚îÇ   ‚îî‚îÄ‚îÄ [YOUR_SYSTEMS].md
‚îî‚îÄ‚îÄ 05.IMPLEMENTATION/             # Generated: User stories (YAML‚ÜíCypress) & parameters
    ‚îú‚îÄ‚îÄ USER_STORIES/              # YAML files with auto-generated Cypress tests
    ‚îî‚îÄ‚îÄ FINE_TUNING/               # Numeric parameter YAML files
```

**Step 4: (Optional) Set up automated testing**

See **[docs/CYPRESS_SETUP.md](docs/CYPRESS_SETUP.md)** for complete Cypress integration guide.

Your YAML user stories will automatically generate end-to-end tests.

---

### Path 2: Existing Project (Brownfield)

**Applying the framework to an existing codebase or product**

**Step 1: Initialize RootSpec in your existing project**

```bash
# Navigate to your project root
cd your-existing-project/

# Initialize RootSpec
npx rootspec init
```

**Step 2: Generate specification with AI (auto-detects your codebase)**

```bash
# Generate adoption prompt with auto-detected context
rootspec prompts adopt
```

**What the CLI automatically detects:**
- **Framework/Stack**: Next.js, Nuxt, React, Vue, Angular, Express, Fastify, etc.
- **Source directories**: `src/`, `lib/`, `app/`, `components/`, `pages/`, etc.
- **Configuration files**: `tsconfig.json`, `package.json`, `vite.config.ts`, etc.
- **Existing specification**: Detects if you have partial specs already

**Example output:**
```
üå≥ Adopt RootSpec Framework

Analyzing your existing codebase...

  ‚úì Found src/
  ‚úì Found components/
  ‚úì Detected framework: Next.js
  ‚úì Found config files: tsconfig.json, package.json, next.config.js

‚úÖ Prompt ready! Copy and paste into your AI assistant:

I have an existing Next.js project and want to adopt the RootSpec framework.

**Source directories:**
- src/
- components/

**Framework/Stack:** Next.js
...
```

**Step 3: Choose your approach**

The prompt will ask you to choose:

**Specification-First (Recommended):**
- Define ideal philosophy and architecture
- Document what SHOULD exist
- Create gap analysis vs. current state
- Refactor incrementally toward spec

**Reverse-Engineering (Pragmatic):**
- Document current architecture as-is
- Infer implicit design decisions
- Extract retrospective philosophy
- Validate spec matches reality

The AI will then help you:
- Map existing code to framework levels
- Define Design Pillars that match your decisions
- Create gap analysis (if Specification-First)
- Document current state accurately (if Reverse-Engineering)

**Time estimate:** 4-8 hours depending on codebase size

**Step 4: Establish as single source of truth**

- Use Design Pillars to filter roadmap
- Reference spec in PRs and planning
- Gradual migration over 3-6 months (if Specification-First)
- Ongoing maintenance (if Reverse-Engineering)

**See [docs/QUICK_START.md](docs/QUICK_START.md) for detailed workflows.**

---

### Path 3: Learning the Framework

**Understanding the framework before committing**

1. **Read [00.SPEC_FRAMEWORK.md](00.SPEC_FRAMEWORK.md)** - Complete framework structure and rules
2. **Read [CLAUDE.md](CLAUDE.md)** - AI assistant quick reference
3. **Review [templates/USER_STORIES/](templates/USER_STORIES/)** - See YAML examples
4. **Check [CHANGELOG.md](CHANGELOG.md)** - Version history and evolution
5. **Try [docs/QUICK_START.md](docs/QUICK_START.md)** - Fast-track guides for both scenarios

**Time investment:** 1-2 hours to understand, 2-8 hours to create your first spec

## Working with AI Assistants

This framework is specifically designed for AI-assisted specification development. Use the prompts below with AI assistants (Claude, GPT-4, etc.) to create and maintain your specifications.

**Quick workflow with CLI (v4.0+):**

1. Run `npx rootspec init` to set up the framework
2. Run `rootspec prompts <command>` to generate context-aware prompts
3. CLI **auto-scans your project** (framework, directories, files) and fills in placeholders
4. Copy the generated prompt and paste into your AI assistant
5. AI reads framework and generates your spec files (01-05)

**CLI Commands for Common Tasks:**
- `rootspec prompts init` - Initialize new specification
- `rootspec prompts adopt` - Adopt framework for existing project
- `rootspec prompts validate` - Validate specification
- `rootspec prompts add-feature` - Add feature to spec
- `rootspec prompts review` - Review feature against spec
- `rootspec prompts` - See all available prompts

**üìö Full prompt library:** See [prompts/](prompts/) directory for detailed prompt templates (auto-filled by CLI)

**üí° Note:** The prompts below are simplified quick versions. Use the CLI commands for auto-contextualized prompts, or see [prompts/](prompts/) for detailed template files.

---

<details>
<summary>üöÄ <strong>Initialize a New Specification</strong></summary>

<br/>

**Quick prompt:**

```
I have copied 00.SPEC_FRAMEWORK.md to my project.

My product idea: [Brief description]

Help me create my specification by asking questions about:
1. Level 1: Mission, 3-5 Design Pillars, inviolable principles
2. Level 2: Design strategies and commitments
3. Level 3: Interaction patterns
4. Level 4: System architecture
5. Level 5: User stories (YAML) and parameters

Follow framework rules: hierarchy, placeholders in L1-4, no upward references.
```

**üìñ Detailed prompt:** [prompts/initialize-spec.md](prompts/initialize-spec.md)

</details>

<details>
<summary>üîÑ <strong>Migrate Specification to Newer Version</strong></summary>

<br/>

**Quick prompt:**

```
I have a spec using framework v[OLD_VERSION]. I've updated to v3.6.0.

Read CHANGELOG.md and help me migrate:
1. Identify breaking changes
2. Rename files if needed
3. Convert user stories to YAML (if from v2.x)
4. Update all cross-references
5. Validate against new framework rules
```

**üìñ Detailed prompt:** [prompts/migrate-spec.md](prompts/migrate-spec.md)

</details>

<details>
<summary>‚úÖ <strong>Validate an Existing Specification</strong></summary>

<br/>

**Quick prompt:**

```
Validate my specification against framework v3.6.0:

Check:
- Reference hierarchy (no upward references)
- No numeric values in L1-4 (placeholders only)
- Design Pillars are emotional, not features
- User stories have test DSL
- All required sections present

Report violations with file:line and suggested fixes.
```

**üìñ Detailed prompt:** [prompts/validate-spec.md](prompts/validate-spec.md)

</details>

<details>
<summary>üîç <strong>Add Feature to Existing Specification</strong></summary>

<br/>

**Quick prompt:**

```
I want to add a new feature: [Description]

Help me:
1. Check which Design Pillar(s) it supports
2. Determine which levels need updates
3. Draft changes for each affected level
4. Ensure changes flow downward only
5. Create user stories and tests (L5)
```

**üìñ Detailed prompt:** [prompts/add-feature.md](prompts/add-feature.md)

</details>

<details>
<summary>üìä <strong>Generate Documentation from Spec</strong></summary>

<br/>

**Quick prompt:**

```
Generate from my specification:
- PRD (Product Requirements Document)
- TDD (Technical Design Document)
- User Story Backlog
- Design Pillar Validation Matrix

Maintain traceability to spec levels.
```

**üìñ Detailed prompt:** [prompts/generate-docs.md](prompts/generate-docs.md)

</details>

<details>
<summary>üéØ <strong>Review Feature Against Specification</strong></summary>

<br/>

**Quick prompt:**

```
Review this feature/implementation: [Description or code]

Check alignment with:
1. L1: Design Pillars and principles
2. L2: Design strategies
3. L3: Interaction patterns
4. L4: System boundaries
5. L5: Parameters

Verdict: ‚úÖ Approved / ‚ö†Ô∏è Needs Changes / ‚ùå Violates Spec
```

**üìñ Detailed prompt:** [prompts/review-feature.md](prompts/review-feature.md)

</details>

---

### Tips for Best Results

**When working with AI assistants:**

1. **Be specific** - Provide context about your domain and constraints
2. **Answer thoroughly** - AI uses your answers to generate better specs
3. **Iterate** - Refine AI-generated content based on your expertise
4. **Validate frequently** - Use the validation prompt regularly
5. **Question suggestions** - If something feels wrong, speak up

**Common commands:**

- `"Check if this violates any hierarchy rules"`
- `"Generate 3 user stories for [SYSTEM] in YAML format"`
- `"Does this feature support at least one Design Pillar?"`
- `"Rewrite this without referencing Level 4 systems"`

**For more tips:** See [prompts/tips-and-best-practices.md](prompts/tips-and-best-practices.md)

---

### Framework-Aware AI Assistants

This framework includes guidance files that AI assistants automatically read:

- **CLAUDE.md** - Brief quick reference for Claude Code
- **00.SPEC_FRAMEWORK.md** - Complete framework specification
- **prompts/** - Detailed prompts for all use cases

When working in a directory containing these files, AI assistants will:

- Understand the five-level hierarchy
- Enforce reference rules
- Guide you through level-by-level specification
- Validate against anti-patterns
- Help create YAML user stories with test DSL

---

## Version Information

**Current Version:** 3.6.0

This framework follows [Semantic Versioning](https://semver.org/):

- **Major versions** (2.0.0) include breaking changes requiring migration
- **Minor versions** (2.1.0) add features while maintaining compatibility
- **Patch versions** (2.0.1) fix bugs and clarify documentation

See [CHANGELOG.md](CHANGELOG.md) for:

- Complete version history
- Migration guides for major version upgrades
- Detailed list of changes in each release

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Contributing

[Add contribution guidelines here]
